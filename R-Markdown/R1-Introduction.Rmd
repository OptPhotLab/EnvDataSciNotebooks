---
title: "R1-Introduction"
author: "Chao Jon Yann"
date: "9 lokakuuta 2018"
output: pdf_document
---

# *Readme* before starting!

Welcome to Environmental Data Science introducing R session. In this
session we start from scratch and assume no prior knowledge of R. Fill in
the blanks as you go to test your understanding.

Used R before?

Did you glance at the first section and think, this is very basic? 

It could still be worth going through the whole notebook or 
just particular sections; there might even be something you skipped over
first time round. 

On the other hand if you understand and can explain each of the 
following terms and how they relate to R, then perhaps this tutorial is
not for you. In this session we will go over:

* variable and operators 
* data types
* objects  
* Data structures 
* lists 
* factors
* dataframes 
* matrices
* functions 
* applying functions.     

By the end of the session you should know what each of these terms
refers to. 

As an aside, the *dictionary* of programming languages
borrows heavily from logic and mathematics. This is especially true
for R, which is a language desgined with mathematics (statistics) in
mind. Knowing the mathematical meaning of a word, e.g. a matrix is 
(imprecisely) a grid of numbers, helps with knowing what R is 
aiming for.


Let's get started!  

#1.Variables and operators

A **variable** is used to store your data or various information that could be
changed.

##1.1. Assign a variable using <- , ->or =
This is how we assign a variable using <- , ->or =

```{r}
x<-1
#now we want to show the contents of x using print function 
print(x)
```

```{r}
y=c(12,3)
print(y)
```

```{r}
c('h','i',9)->z
print(z)
```

##1.2. Give your variable a name!
The name of a variable should be unique, and can consist of letters, numbers, underline or dots. The
variable should start with: a letter or a dot (this dot cannot followed by a number), but cannot start
with a number or underline.
For example, can you find which variable name is not correct?

x.1<-1 ; x_2<-2 ;.x<-3 ; 4y<-5 ; *_z<-6; _2<-7, .2a<-8*

Try here:

```{r}

```

##1.3. Data types

Each variables has a **data types**. The data type of a variable is its
defining quality, it is what it is!

In R, there are several basic data types in R that we typically use:

character: ‘a’ 

numeric: 2,0, or 5.6 

integer: 4L (the L means R will store 4 as integer) 

logical: TRUE, FALSE

The above datatypes are referred to as *atomic* in R speak.

The data types of R objects can be the variable types. These variables can consist of a dataset.
Try to find the type of above mentioned variables x,y,z using class(), and the structure of x,y,z using str()
The common used structure of the dataset in R include:
vector (basis), factor, matrix,array, data frame and list.

##1.4. Operators 

we can use operator to. . .

###1.4.1.Arithmetic operators

add, substract, mutiply, divide, equal, expeonent: 

+, -, *, /, =, ^ 

```{r}
math1=5+6*8-9+5/6
print(math1)
4^3
```

###1.4.2.Relational operators

great, less, equal: **>, <, >=, <=, ==, !=**

```{r}
34!=5
```

###1.4.3. Logical operators

and, or, not:       **&, |, !** 

```{r}

```


###1.4.4.Miscellaneous Operators

colon operator: **:**, generate a sequence of numbers

```{r}
1:10
```

%in%: detect if the elements in **A** also in **B**

```{r}
A<-1:10
B<-3:6
print(A%in%B)
```


### Objects and class

#2. Data structures and Control flow


##2.1. Data structures are ...

Data structures are ...

###2.1.1. A vector is the first basic data structure.

Vectors are one dimension array that can consist of numberic, character,or logical data. All the elements inside a vector should be one data type (numberic, character,or logical).

A vector is formed using function: c(), which combines all the arguments into one common type.

For example (1) Create a vector named as a, store letters of b to e into a, (2) print a, (3) check type of a, and (4) structure of a.

```{r}
#(1)create a character vector: a
a<-c('b','c','d','e')
#(2)print: a
print(a)
```

```{r}
#(3)check type of a
class(a)
```

```{r}
#(4)check structure of a
str(a)
```

Try to (1) create a vector named as a1, store first 10 numbers into a1,(2) print a1, (3) check type of a1, and
(4) structure of a1.
Which type of above mentiond variable z (z<-c(‘h’,‘i’,9))?

```{r}

```

###2.1.2. A matix is a two-dimentsion array in where all the elements should be same type

Matices are created by matrix() function.

```{r}
d<-c(1:20)
#create a matrix
matr1<-matrix(d,nrow = 5,ncol=4,byrow = T,
              dimnames =list(c('r1','r2','r3','r4','r5'),
                             c('c1','c2','c3','c4')))
matr1
```

```{r}
str(matr1)
```

###2.1.3. An array is similar to a matrix, but can have more than two dimensions.

Arrays are created by array() function

```{r}
x<-c('a1','a2','a3')
y<-c('b1','b2')
z<-c('c1','c2','c3','c4','c5')
mydata<-c(1:30)
array1<-array(mydata,c(3,2,5),
dimnames = list(x,y,z))
array1
```

###2.1.4. A list can contain mant types of datasets.

A list is ...

```{r}
alist<-list(c('b','c','d','e'),
            c('control','control','drought'),
            c(1:10),
            c(1L,3L),
            88,
            '%&()',
            c(0.3,2.34,6.57,0),
            3+9,
            c('4','9'),
            list(c(1,2,'g')))
print(alist)
```

```{r}
class(alist)
```

```{r}
str(alist)

```

##2.4. Conditions and Loops using vector: if, for, while, repeat

###2.4.1. conditions

if (condition) {statement} or if (condition) statement

```{r}
x<-10
if (x<5) {print('X is smaller than 5')}
if (x>5) print('X is larger than 5')
```

if (condition) { statement1 } else { statement2 }
or
if (condition) { statement1 } else if (condition2){ statement2 } else if (condition3){ statement3 } else if
(condition4){ statement4 } else { statement5 }

```{r}
y<-20
if (y>10) {
print ('y is larger than 10')
} else {
print('y is smaller than 10')
}
```

```{r}
y<-20
if (y<0) {
print ('y is a negative number')
} else if (y==0) {
print('y is 0')
} else if (y>0 & y <10) {
print('y is greater than 0 and smaller than 10')
} else if (y==10) {
print ('y is 10')
} else if (y>10 & y <20){
print ('y is greater than 10 and smaller than 20')
} else {
print ('y is 20')
}

```

ifesle (statement, a, b) #if statement is true, print a, if false print b

```{r}
z<-c(1,10,30)
ifelse (z==10|z>15,'yes','no')

```

##2.4.2. Loop

for (variable in sequence) {statement}


```{r}
x<-c(1:10)
y<-2
for (i in x){
 z<-y+x
}
print(z)
```

while (condition) {statement}

```{r}
x<-2
while(x<10) {
  print('yes')
  x=x+2
  }
```

repeat()

```{r}

```

#2.5 Advanced data structure: Dataframe 

Dataframe is the main and fundamental data structure used in R

Dataframes are generated by data.frame() function, which has silimar format with the dataset we use in Excel, SPASS, SigmaPlot etc.

In a dataframe: (1)the columns are variables, the rows are observations (the row numbers will be object numbers); (2) all the variables are of same length.

```{r}
#create a dataframe
x=c(1:3)
y=c('a','b','c')
z=c(30,40,50)
df1<-data.frame(x,y,z)
#print df1
print(df1)
```

```{r}
#check the structure of df1
str(df1)
```

Try to create a new dataframe names as mydata, which has 2 variables and 4 objects:

```{r}

```

#3. Additional data type: factors

Factor is created using a vector

All the elements inside this factor will be character. A factor can efficiently store characters, because only once per character is stored.

```{r}
#create a vector
treatment<-c('control','control','drought','nutrient','drought')
#check the type of treatment
class(treatment)
```

```{r}
#check the structure of treatment
str(treatment)
```

Now let’s create a factor and check the class and structure of this factor. 

Can you see the difference between **treatment** and **treatment.factor**?

```{r}
#create a factor
treatment.factor<-factor(treatment)
#check the type
class(treatment.factor)

```

```{r}
#check the structure
str(treatment.factor)
```

Yes, the numbers of these unique character are called levels in R, which can be examined using **levels()** function

```{r}
#check levels of treatment.factor
levels(treatment.factor)
```

Try to create a factor named as **plantnum.factor** which is from a vector **plant.number** contains 5 elements
c(1,2,3,3,2). How many levels **plantnum.factor** have, and what are they? Can you see the difference between **plant.number** and **plantnum.factor**?

```{r}

```


#4. Functions and Applying functions

Functions are central to the way R works; think of them as the
building blocks of larger programs. Just like building blocks,
functions are elements of a larger whole. If you want to take the next
step beyond writing simple scripts, then functions are your friend!

In simple terms, a function takes an input, does something to it, 
then returns something else which is the results of that something.  
In R language, functions consist of *arguments* which are the input,
the *body* which is the bit where things happen, and the *name*, which
is self evident! 

##4.1. built-in functions

Most things in R involve functions, typically these are built-in to 
the language or perhaps part of a package that you have installed.

When you print something to the screen then you are using the **print** 
function:
```{r}
print("print is a commonly used function!")
```

You can take a look at the contents of a function by typing the function
name, but missing out the paranthesis:

```{r}

print

```

You can get information (help) on any function by placing the question 
mark operator at the front of a function (e.g "?function"), 
try it out with print:
```{r}


```

The code inside the function is called the *body*, the input to the
functions is referred to as the *argument*(s)

Sometimes there is more than one function that achieves a similar result.
Can you think of another function that prints messages to the screen?

```{r}

```
##4.2. User-defined functions

Built-in functions allow us to get stuff done, however user-defined 
functions allow us to build stuff! 

First we need our function to have a purpose. Maybe our instrument
has a linear calibration function. The aim of our function is to calculate
this calibration from out data i.e. takes an input value, 
and multiply by a calibration coefficient to yield the calibrated value. 

```{r}

cal.eq <- function(instrument.data,cal.coeff=2.4){ 
       instrument.data * cal.coeff
    }

```

Stepping through our function, one part at a time. The name of the
function is *cal.eq*, the body of the function is  the part in 
between the curly braces. Our function has two input arguments, 
the first is *instrument.data*, and the other is our calibration
coefficient *cal.coeff* which is set to a default value of 2.4.   

Now try to test out the function with some data,
x <- c(1:10)

```{r}


```
One important note about functions; the output of an R function is
whatever is calculated on the last line of the body. In our case we only
have one line so that is what we get back. 

##4.3. The apply family and anonymous functions

The *apply* family are a special group of functions that most R users
are familiar with. In essence apply functions are similar to for loops,
in fact in R when you find yourself reaching for a for-loop we often ask
ourselves can we use apply instead?

Apply functions iterate (repeat) a function over a datastructure. We
can use the *paste* function to join two characters together e.g. 'hi '
and 'there'

```{r}
paste('hi ','there')

```
We could use apply to paste 'hi' to list of different words. We 
do this by defining a new *anonymous* function within the apply
call. An *anonymous* function is simply a function with no name!
Let's use the lapply function, as this is designed to work on 
vectors

```{r}
sentenc.e <- c("This "," is a ", " setence." )


# now lets use apply to mess up our sentence!

nonsense <- lappy(sentenc.e, function(input) paste(input," oops ")  )  

```
We have now turned out sentence into nonsense! However if you
inspect the *class()* of  nonsense you will notice that it is a list!

```{r}
class(nonsense)

```

This is because lapply returns a list. Lists are a little tricky
to work with. To convert back to a vector you can use another function:

```{r}
nonsense <- unlist(nonsense)

```
Now we have a character vector, just like our original sentence.

In R there are a bunch of apply functions, each one is intended for
slighly different inputs and outputs. Here are a few that you may
come across:
* lapply: input are vectors and lists. Outputs are list
* sapply: input are vectors and lists. Outputs are "user friendly"
* mapply: multivariate version of sapply. Outputs are "user friendly"

what is the difference in using sapply over lapply in the example above?

```{r}

```


# 5. Other stuff

We have only scratched the very basics of R in this tutorial. We will cover
more  

## 5.1 installing packages 

Functions are bundled together in packages (libraries). Each package
has a general theme e.g. ggplot2 is for improved plotting capabilites.
You can download packages using the *install.packages* function. 

## 5.2 Additional resources

R is an opensource language, with an open source ethos! This means
there are lots of good free resources available should you wish to 
learn more about the fundamentals. For programmers coming from 
other languages, be sure to check out *The R inferno*. There are also
a bunch of online tutorials for you to follow should you 
have time, Google is your friend here!








